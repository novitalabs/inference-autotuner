
## Mini-milestone: Documentation Reorganization

> Separate Troubleshooting chapter from README into a standalone document, and leave a link for README.

<details>
<summary>Documentation Reorganization</summary>

* *Claude*:
  **Documentation Refactoring:**
  
  **1. Created Standalone Troubleshooting Guide** (`docs/TROUBLESHOOTING.md`)
  - Comprehensive guide with 13 common issues and solutions
  - Sections:
    * InferenceService deployment issues
    * GPU resource problems
    * Docker and Kubernetes configuration
    * Model download and transfer
    * Benchmark execution errors
    * Monitoring and performance tips
  - 400+ lines of detailed troubleshooting content
  
  **2. Updated README.md**
  - Replaced verbose Troubleshooting section (420+ lines) with concise summary
  - Added link to `docs/TROUBLESHOOTING.md`
  - Quick reference list of common issue categories
  - 50% reduction in README length while preserving all information
  
  **Files Modified:**
  1. ‚úÖ `docs/TROUBLESHOOTING.md` - Created comprehensive standalone guide
  2. ‚úÖ `README.md` - Replaced detailed troubleshooting with link and summary
  
  **Benefits:**
  - üìâ README more readable and maintainable
  - üìà Troubleshooting information easier to find and reference
  - üìà Follows project convention of placing detailed docs in `./docs/`

</details>

---

## Mini-milestone: CLI Default Behavior Improvement

> When use `--mode docker`, --direct should be default

<details>
<summary>CLI Default Behavior Improvement</summary>

* *Claude*:
  **CLI Usability Enhancement:**
  
  **Implementation:**
  - Modified `src/run_autotuner.py` argument parsing
  - Added automatic flag setting: `if args.mode == 'docker': args.direct = True`
  - Updated help text: `--direct` now says "default for docker mode"
  - Updated usage examples to remove redundant `--direct` flag
  
  **Behavior:**
  - **Before**: `python src/run_autotuner.py examples/docker_task.json --mode docker --direct`
  - **After**: `python src/run_autotuner.py examples/docker_task.json --mode docker`
  
  **Rationale:**
  - Docker mode always uses DirectBenchmarkController (no K8s BenchmarkJob CRD)
  - Requiring explicit `--direct` flag was redundant
  - Simplifies command-line usage for most common case
  
  **Files Modified:**
  1. ‚úÖ `src/run_autotuner.py` - Added automatic flag logic, updated help text
  
  **Benefits:**
  - üìâ Simpler command-line interface
  - üìà Clearer default behavior
  - üìà Better user experience

</details>

---

## Mini-milestone: Code Formatting - Black Formatter Integration

> Import python black formatter in project

<details>
<summary>Code Formatting - Black Formatter Integration</summary>

* *Claude*:
  **Initial Black Setup:**
  
  **1. Added Dependencies**
  - Added `black>=24.0.0` to `requirements.txt`
  - Installed Black 25.9.0
  
  **2. Created Configuration** (`pyproject.toml`)
  - Line length: 100 characters
  - Target Python: 3.8, 3.9, 3.10, 3.11
  - Excluded: env, venv, third_party, build artifacts
  
  **3. Formatted Codebase**
  - Reformatted 7 Python files:
    * `src/run_autotuner.py`
    * `src/controllers/*.py` (5 files)
    * `src/utils/optimizer.py`
  
  **4. Documentation** (`docs/DEVELOPMENT.md`)
  - Installation instructions
  - Usage commands
  - IDE integration (VS Code, PyCharm)
  - Pre-commit hook example
  
  **Files Modified:**
  1. ‚úÖ `requirements.txt` - Added black dependency
  2. ‚úÖ `pyproject.toml` - Created formatter configuration
  3. ‚úÖ `docs/DEVELOPMENT.md` - Created development guide
  4. ‚úÖ All Python source files - Reformatted

</details>

> Can we configure black to use 2 empty lines for intervals between top-level functions?

<details>
<summary>Verified Black already enforces PEP 8 standard of 2 blank lines; documented in style guide</summary>

* *Claude*:
  **Blank Lines Configuration Analysis:**
  
  **Finding:**
  - Black ALREADY enforces 2 blank lines between top-level definitions by default
  - This is part of PEP 8 that Black implements
  - NOT configurable - it's opinionated design
  
  **Verification:**
  - Checked existing code: Confirmed 2 blank lines between classes and functions
  - Example from `run_autotuner.py`:
    ```python
    from utils.optimizer import ...
                              # ‚Üê blank line 1
                              # ‚Üê blank line 2
    class AutotunerOrchestrator:  # ‚Üê top-level class
        ...
    
    
    def main():                   # ‚Üê top-level function
    ```
  
  **Documentation Updates:**
  - Updated `pyproject.toml` with comment: "Blank lines: 2 between top-level definitions (default, per PEP 8, not configurable)"
  - Updated `docs/DEVELOPMENT.md` Code Style Guidelines section:
    * Added blank lines subsection
    * 2 blank lines between top-level definitions
    * 1 blank line between methods inside a class
    * Note that Black enforces automatically
  
  **Files Modified:**
  1. ‚úÖ `pyproject.toml` - Added explanatory comment
  2. ‚úÖ `docs/DEVELOPMENT.md` - Documented blank line rules
  
  **Status:**
  - ‚úÖ Feature already working as expected
  - ‚úÖ Documented for future reference

</details>

---


## Mini-milestone: Benchmark Results Parsing and Objective Score Calculation

> Complete function `calculate_objective_score` according to the results value

<details>
<summary>Benchmark Results Parsing and Objective Score Calculation</summary>

* *Claude*:
  **Problem Analysis:**
  - `calculate_objective_score()` was placeholder returning `Infinity` scores
  - `_parse_results()` was reading wrong files and incorrect structure
  - Needed to understand genai-bench actual output format

  **Investigation:**
  - Examined actual benchmark output directory structure
  - Found genai-bench creates multiple JSON files:
    * `D100_100_text-to-text_num_concurrency_1_time_9s.json` (result files)
    * `D100_100_text-to-text_num_concurrency_4_time_3s.json`
    * `experiment_metadata.json` (metadata, not results)
  - Analyzed JSON structure: `{"aggregated_metrics": {...}}`
  - Identified available metrics: e2e_latency, ttft, tpot, throughput stats

  **Implementation Changes:**

  **1. Enhanced DirectBenchmarkController._parse_results():**
  - **File Filtering**: Changed from `glob("**/*.json")` to `glob("D*.json")`
    * Only reads actual result files, excludes metadata
  - **Multiple Concurrency Handling**: Parses all result files (one per concurrency level)
  - **Proper Structure Navigation**: Extracts from `data["aggregated_metrics"]`
  - **Comprehensive Aggregation**: Averages metrics across all concurrency levels
  
  **Metrics Extracted:**
  - **Latency**: mean/min/max/p50/p90/p99 E2E latency (seconds)
  - **Throughput**: mean/max output and total throughput (tokens/s)
  - **Token-level**: mean TTFT, mean TPOT
  - **Request stats**: total/completed/error requests, success rate

  **2. Completed calculate_objective_score():**
  
  **Supported Objectives:**
  1. `minimize_latency` (default):
     - Uses `mean_e2e_latency` (seconds)
     - Fallback to `p50_e2e_latency`
     - Lower is better
  
  2. `maximize_throughput`:
     - Uses `mean_total_throughput` (tokens/s)
     - Falls back to output or max throughput
     - Score negated for minimization: `-throughput`
     - Lower (more negative) = higher throughput = better
  
  3. `minimize_ttft` (NEW):
     - Optimizes Time to First Token
     - Lower is better
  
  4. `minimize_tpot` (NEW):
     - Optimizes Time Per Output Token
     - Lower is better

  **Features:**
  - Clear logging of calculated scores
  - Graceful fallback for missing metrics
  - Error handling with appropriate defaults
  - Informative warnings

  **Testing:**
  ```
  Concurrency levels: [4, 1]
  Mean E2E Latency: 0.1892s
  Mean Total Throughput: 2304.82 tokens/s

  Objective Scores:
    minimize_latency: 0.1892
    maximize_throughput: -2304.82 (negated)
  ```

  **Files Modified:**
  1. ‚úÖ `src/controllers/direct_benchmark_controller.py` - Enhanced `_parse_results()` (100+ lines)
  2. ‚úÖ `src/utils/optimizer.py` - Completed `calculate_objective_score()` with 4 objectives

  **Benefits:**
  - ‚úÖ No more `Infinity` scores - proper metric extraction
  - ‚úÖ Supports 4 optimization objectives
  - ‚úÖ Handles multiple concurrency levels correctly
  - ‚úÖ Comprehensive metric aggregation
  - ‚úÖ Clear logging for debugging
  - ‚úÖ Graceful error handling

  **Key Learnings:**
  1. genai-bench creates separate result files per concurrency level
  2. Result files follow pattern `D<input>_<output>_<task>_num_concurrency_<N>_time_<T>s.json`
  3. Metrics are nested under `aggregated_metrics` key
  4. Need to aggregate across multiple concurrency runs for fair comparison
  5. Throughput maximization requires score negation (optimizer minimizes)

</details>

---
---

# üéâ MILESTONE 1: Core Autotuner Foundation

> Okay, I announce that the first milestone accomplished! Summary milestone 1 concisely and update it into prompts.md

<details>

**Status**: ‚úÖ COMPLETED
**Date**: October 24, 2025
**Objective**: Establish solid foundation for LLM inference parameter autotuning with complete functionality, proper documentation, and code standards

## Accomplishments

### 1. Documentation Structure & Organization
- ‚úÖ Separated 420+ line Troubleshooting section into standalone `docs/TROUBLESHOOTING.md`
- ‚úÖ Created comprehensive development guide: `docs/DEVELOPMENT.md`
- ‚úÖ Established documentation conventions (detailed docs in `./docs/`)
- ‚úÖ Improved README readability and maintainability

### 2. Code Formatting & Standards
- ‚úÖ Integrated **black-with-tabs** formatter for consistent code style
- ‚úÖ Configuration: 120-char lines, tab indentation, single quote preservation
- ‚úÖ Formatted entire codebase (7 Python files, 1957+ lines)
- ‚úÖ IDE integration guides (VS Code, PyCharm)
- ‚úÖ PEP 8 compliance with 2 blank lines between top-level definitions

### 3. CLI Usability Improvements
- ‚úÖ Made `--direct` flag automatic when using `--mode docker`
- ‚úÖ Simplified command-line interface
- ‚úÖ Updated help text and usage examples
- ‚úÖ Better default behaviors for common use cases

### 4. Benchmark Results Parsing & Scoring
- ‚úÖ **Fixed critical bug**: Proper genai-bench result file parsing
- ‚úÖ Enhanced `DirectBenchmarkController._parse_results()`:
  - Reads correct result files (D*.json pattern)
  - Handles multiple concurrency levels
  - Aggregates metrics across all runs
  - Extracts 15+ performance metrics
- ‚úÖ **Completed `calculate_objective_score()`** with 4 optimization objectives:
  - `minimize_latency` - E2E latency optimization
  - `maximize_throughput` - Token throughput optimization
  - `minimize_ttft` - Time to First Token optimization
  - `minimize_tpot` - Time Per Output Token optimization
- ‚úÖ Comprehensive metric extraction:
  - Latency: mean/min/max/p50/p90/p99 E2E latency
  - Throughput: output and total token throughput
  - Request statistics: success rate, error tracking
- ‚úÖ **Result**: No more Infinity scores, proper experiment comparison

### 5. Web Integration Readiness
- ‚úÖ **Comprehensive codebase analysis**: Zero blockers found
- ‚úÖ Created detailed readiness assessment: `docs/WEB_INTEGRATION_READINESS.md`
- ‚úÖ Verified all controllers fully implemented (no placeholder functions)
- ‚úÖ Confirmed orchestrator is programmatically importable
- ‚úÖ Documented data structures (input/output formats)
- ‚úÖ Technology stack recommendations (FastAPI, React/Vue)
- ‚úÖ API endpoint specifications
- ‚úÖ Implementation roadmap with effort estimates

## Technical Achievements

**Code Quality:**
- 1,957 lines of production Python code
- 100% method implementation (no placeholders in critical paths)
- Comprehensive error handling and logging
- Clean separation of concerns (controllers, orchestrator, utilities)

**Functionality:**
- ‚úÖ Full Docker mode support (standalone, no K8s required)
- ‚úÖ OME/Kubernetes mode support
- ‚úÖ Grid search parameter optimization
- ‚úÖ Multi-concurrency benchmark execution
- ‚úÖ Comprehensive result aggregation and scoring
- ‚úÖ Automatic resource cleanup

**Documentation:**
- README.md - User guide with installation and usage
- CLAUDE.md - Project overview and development guidelines
- docs/TROUBLESHOOTING.md - 13 common issues and solutions
- docs/DEVELOPMENT.md - Code formatting and contribution guide
- docs/DOCKER_MODE.md - Docker deployment guide
- docs/OME_INSTALLATION.md - Kubernetes/OME setup
- docs/GENAI_BENCH_LOGS.md - Benchmark log viewing
- docs/WEB_INTEGRATION_READINESS.md - Web development readiness

## Key Metrics

- **Files Modified**: 15+
- **Documentation Pages**: 8
- **Code Lines**: 1,957 (production code)
- **Test Results**: Successfully parsed real benchmark data
  - Concurrency levels: [1, 4]
  - Mean E2E Latency: 0.1892s
  - Mean Throughput: 2,304.82 tokens/s
- **Formatting**: 7 Python files reformatted with tabs
- **Zero Blockers**: Ready for next milestone

## Architecture Status

**Controllers (All Complete):**
- ‚úÖ BaseModelController - Abstract interface (4 methods)
- ‚úÖ DockerController - Docker deployment (485 lines)
- ‚úÖ OMEController - Kubernetes deployment (225 lines)
- ‚úÖ BenchmarkController - K8s BenchmarkJob (218 lines)
- ‚úÖ DirectBenchmarkController - CLI benchmark (435 lines)

**Core Components:**
- ‚úÖ AutotunerOrchestrator - Main task coordinator (384 lines)
- ‚úÖ Parameter grid generation - Cartesian product
- ‚úÖ Objective score calculation - 4 optimization modes
- ‚úÖ Result storage - JSON output format

**Data Flow:**
```
Task JSON ‚Üí Orchestrator ‚Üí Parameter Grid ‚Üí For each config:
  Deploy ‚Üí Wait Ready ‚Üí Benchmark ‚Üí Score ‚Üí Cleanup
‚Üí Best Configuration ‚Üí Save Results
```

## Lessons Learned

1. **genai-bench Output Structure**: Creates separate JSON files per concurrency level with nested `aggregated_metrics`
2. **Black Limitations**: Standard Black can't use tabs; black-with-tabs fork required
3. **Score Negation**: Maximization objectives need score negation for minimizer-based optimizer
4. **Multi-Concurrency**: Must aggregate metrics across concurrency levels for fair comparison
5. **Programmatic Usage**: Orchestrator can be imported and used in web applications without modification

## Next Milestone: Web Interface

**Objective**: Build web frontend and backend for interactive autotuning

**Readiness**: ‚úÖ All blockers cleared
- Orchestrator is importable and functional
- Data structures well-defined
- API endpoints specified
- Technology stack recommended

**Estimated Effort**: 1-2 weeks for MVP

</details>

---


## Mini-milestone: Web Stack Technology Investigation

> Investigate the best practice on web application technical stack, fit for our project.

<details>
<summary>Web Stack Technology Investigation</summary>

* *Claude*:
  **Comprehensive Web Stack Investigation:**
  
  **Research Methodology:**
  - Web search for 2025 Python framework trends
  - Analysis of FastAPI vs Flask vs Django
  - Task queue comparison (ARQ vs Celery vs RQ)
  - Real-time communication options (WebSocket vs SSE)
  - Frontend framework analysis
  
  **Key Findings (2025 Trends):**
  
  **Backend Frameworks:**
  - **FastAPI**: 70K+ stars (15K in 2020), fastest growth for AI/ML apps
  - Performance: 3-5x faster than Django, better async than Flask
  - Features: Auto-docs (Swagger), Pydantic validation, async-native
  - Best for: Microservices, APIs, async-heavy apps
  
  - **Flask**: 60K+ stars, lightweight, flexible
  - Cons: Needs extensions for validation, docs, async support
  
  - **Django**: 75K+ stars, mature, batteries-included
  - Cons: Slower, limited async support, more boilerplate
  
  **Task Queues:**
  - **ARQ**: AsyncIO-native, perfect for FastAPI, simple setup
  - Use case: MVP, < 10 concurrent tasks, FastAPI projects
  
  - **Celery**: Battle-tested, feature-rich, advanced monitoring (Flower)
  - Use case: Production, > 10 tasks, need advanced features
  
  - **RQ**: Simple, Redis-based, but sync-only
  
  **Real-Time Updates:**
  - **SSE (Server-Sent Events)**: Recommended for progress updates
    * Unidirectional (server ‚Üí client)
    * HTTP-based, auto-reconnection
    * Simpler than WebSocket
    * Firewall-friendly
  
  - **WebSocket**: Only needed for bidirectional (chat, gaming)
  
  **Frontend:**
  - **React + TypeScript**: Most popular (220K stars), largest ecosystem
  - Alternatives: Vue 3 (easier), Svelte (faster)
  
  **Recommended Stack:**
  ```yaml
  Backend:
    Framework: FastAPI 0.104+
    Task Queue: ARQ (MVP) ‚Üí Celery (Production)
    Database: SQLite (MVP) ‚Üí PostgreSQL (Production)
    Real-time: Server-Sent Events (SSE)
    Cache: Redis 7+
  
  Frontend:
    Framework: React 18 + TypeScript 5
    Build: Vite 5
    State: TanStack Query + Zustand
    UI: Material-UI or Tailwind CSS
    Charts: Recharts
  ```
  
  **Migration Path:**
  - Phase 1 (Week 1-2): FastAPI + ARQ + SQLite + React
  - Phase 2 (Week 3-4): Add PostgreSQL + Auth
  - Phase 3 (Month 2): Migrate to Celery + Monitoring
  
  **Documentation Created:**
  1. ‚úÖ `docs/WEB_STACK_INVESTIGATION.md` (20+ pages)
     - Technology comparisons with code examples
     - Migration path MVP ‚Üí Production
     - Implementation priorities
     - Success criteria
  
  **Decision Made:**
  - **FastAPI + ARQ + SQLite + React + TypeScript**
  - Modern, async-native, type-safe stack
  - Easy MVP ‚Üí Production path
  - 2-4 weeks estimated for functional MVP

</details>

---

## Mini-milestone: Backend Foundation Setup

> FastAPI + ARQ + SQLite + React + typescript, now set up server foundation.

<details>
<summary>Backend Foundation Setup</summary>

* *Claude*:
  **Complete Backend Foundation Implementation:**
  
  **Project Structure Created:**
  ```
  web/backend/
  ‚îú‚îÄ‚îÄ main.py              # FastAPI app entry point
  ‚îú‚îÄ‚îÄ dev.py               # Development server runner
  ‚îú‚îÄ‚îÄ requirements.txt     # Dependencies
  ‚îú‚îÄ‚îÄ .env.example         # Environment template
  ‚îú‚îÄ‚îÄ README.md            # Documentation
  ‚îú‚îÄ‚îÄ api/                 # API endpoints
  ‚îÇ   ‚îú‚îÄ‚îÄ tasks.py         # Task CRUD (8 endpoints)
  ‚îÇ   ‚îú‚îÄ‚îÄ experiments.py   # Experiment queries (2 endpoints)
  ‚îÇ   ‚îî‚îÄ‚îÄ system.py        # Health & system info (3 endpoints)
  ‚îú‚îÄ‚îÄ core/
  ‚îÇ   ‚îî‚îÄ‚îÄ config.py        # Pydantic settings
  ‚îú‚îÄ‚îÄ db/
  ‚îÇ   ‚îú‚îÄ‚îÄ models.py        # SQLAlchemy models (Task, Experiment)
  ‚îÇ   ‚îî‚îÄ‚îÄ session.py       # Async session management
  ‚îú‚îÄ‚îÄ schemas/
  ‚îÇ   ‚îî‚îÄ‚îÄ __init__.py      # Pydantic v2 schemas
  ‚îî‚îÄ‚îÄ workers/
      ‚îú‚îÄ‚îÄ autotuner_worker.py  # ARQ worker
      ‚îî‚îÄ‚îÄ client.py        # Job enqueue client
  ```
  
  **Implementation Details:**
  
  **1. FastAPI Application (`main.py`):**
  - ASGI app with lifespan management
  - CORS middleware for frontend integration
  - Router inclusion (tasks, experiments, system)
  - Auto-documentation at `/docs`
  - Health check endpoints
  
  **2. Database Layer (`db/`):**
  - SQLAlchemy 2.0 with async support
  - Models: Task, Experiment with proper relationships
  - Enums: TaskStatus, ExperimentStatus
  - Async session factory
  - Auto-create tables on startup
  
  **3. Pydantic Schemas (`schemas/`):**
  - Request validation: TaskCreate, TaskUpdate
  - Response models: TaskResponse, ExperimentResponse
  - Type-safe with Field descriptions
  - Proper alias handling for reserved names
  - Pydantic v2 syntax (model_config)
  
  **4. API Endpoints (`api/`):**
  
  **Tasks Endpoints:**
  - POST /api/tasks - Create task
  - GET /api/tasks - List tasks (with filters)
  - GET /api/tasks/{id} - Get by ID
  - GET /api/tasks/name/{name} - Get by name
  - PATCH /api/tasks/{id} - Update task
  - DELETE /api/tasks/{id} - Delete task
  - POST /api/tasks/{id}/start - Start execution (enqueues ARQ job)
  - POST /api/tasks/{id}/cancel - Cancel running task
  
  **Experiments Endpoints:**
  - GET /api/experiments/{id} - Get experiment
  - GET /api/experiments/task/{id} - List task experiments
  
  **System Endpoints:**
  - GET /health - Quick health check
  - GET /api/system/health - Detailed health (DB, Redis)
  - GET /api/system/info - System information
  
  **5. ARQ Worker Integration (`workers/`):**
  - `autotuner_worker.py`: Background task execution
    * Imports orchestrator from src/
    * Runs experiments in sequence
    * Updates database with progress
    * Calculates objective scores
    * Finds best configuration
  - `client.py`: Job enqueue functions
    * Redis pool management
    * Job status queries
  - Worker settings: 5 max concurrent jobs, 2-hour timeout
  
  **6. Configuration (`core/config.py`):**
  - Pydantic Settings with .env support
  - Database URL configuration
  - Redis connection settings
  - CORS origins
  - Autotuner defaults (docker mode, model path)
  
  **7. Dependencies Installed:**
  - fastapi==0.120.0
  - uvicorn[standard]==0.38.0
  - sqlalchemy==2.0.44
  - aiosqlite==0.21.0
  - pydantic==2.12.3
  - pydantic-settings==2.11.0
  - arq==0.26.3
  - redis==5.3.1
  - httpx==0.28.1 (for testing)
  
  **Key Technical Decisions:**
  
  **Async Throughout:**
  - FastAPI async endpoints
  - SQLAlchemy async ORM
  - aiosqlite for async SQLite
  - ARQ async task queue
  
  **Type Safety:**
  - Pydantic v2 for validation
  - Type hints throughout
  - Auto-generated OpenAPI schema
  
  **Integration with Existing Code:**
  - Workers import from `src/run_autotuner.py`
  - Uses existing `AutotunerOrchestrator`
  - Leverages `generate_parameter_grid()` and `calculate_objective_score()`
  - No changes to core autotuner code needed
  
  **Challenges Resolved:**
  
  **1. Pydantic v2 Syntax:**
  - Issue: `model_config` name collision (reserved attribute)
  - Solution: Used Field aliases for database columns
  - Changed API schema to use `model`, `optimization`, `benchmark`
  
  **2. Import Path:**
  - Issue: Workers need to import from parent `src/` directory
  - Solution: Added `sys.path.insert(0, ...)` in worker
  
  **3. Async Database:**
  - Issue: Need async session management
  - Solution: async_sessionmaker with AsyncSession
  - Proper session lifecycle with dependency injection
  
  **Files Created:** 15 Python files
  **Lines of Code:** ~1,200 lines
  **API Endpoints:** 13 endpoints
  
  **Testing:**
  - ‚úÖ Successfully imported FastAPI app
  - ‚úÖ All dependencies installed
  - ‚úÖ Code formatted with black-with-tabs
  - ‚úÖ Ready for development server startup
  
  **Usage:**
  ```bash
  # Start Redis
  docker run -d -p 6379:6379 redis:7-alpine
  
  # Start API server
  cd web/backend && python dev.py
  
  # Start ARQ worker (separate terminal)
  cd web/backend && arq workers.autotuner_worker.WorkerSettings
  
  # Access API docs
  open http://localhost:8000/docs
  ```
  
  **Benefits:**
  - ‚úÖ Production-ready architecture
  - ‚úÖ Fully async for performance
  - ‚úÖ Type-safe with validation
  - ‚úÖ Auto-documented API
  - ‚úÖ Background task queue integrated
  - ‚úÖ Easy to test and develop
  - ‚úÖ Ready for frontend integration
  
  **Next Steps:**
  - Create React frontend
  - Implement SSE for real-time updates
  - Add authentication (JWT)
  - Create Docker Compose setup

</details>

---

## Mini-milestone: Backend Server Testing & Database Migration to Home Directory

> Install env for web/backend and test to run the server, reuse the `env` folder, don't create new venv.

<details>
<summary>Backend Server Testing & Database Migration to Home Directory</summary>

* *Claude*:
  **Environment Setup & Testing:**
  
  **1. Corrected Virtual Environment Usage:**
  - Removed incorrectly created `web/backend/venv` directory
  - Installed dependencies in existing shared `env` folder at `/root/work/inference-autotuner/env`
  - Verified packages: fastapi 0.120.0, uvicorn 0.38.0, sqlalchemy 2.0.44, aiosqlite 0.21.0, pydantic 2.12.3, arq 0.26.3, redis 5.3.1
  
  **2. Redis & Server Startup:**
  - Redis container already running (autotuner-redis on port 6379)
  - Started FastAPI server successfully on port 8000
  - Database initialized with tasks and experiments tables
  - All SQL indexes created properly
  
  **3. API Endpoints Testing:**
  - ‚úÖ `GET /health` - Quick health check
  - ‚úÖ `GET /api/system/health` - Detailed health (DB: ok, Redis: ok)
  - ‚úÖ `GET /api/system/info` - System information
  - ‚úÖ `POST /api/tasks/` - Created task successfully (ID: 1, "docker-simple-tune")
  - ‚úÖ `GET /api/tasks/` - List tasks
  - ‚úÖ `GET /api/tasks/1` - Get task by ID
  - ‚úÖ API documentation available at `/docs` (Swagger UI)
  - ‚úÖ OpenAPI spec at `/openapi.json` (14 endpoints)
  
  **Database Migration to Home Directory:**
  
  **4. User Feedback: Move Database to Home Directory**
  - User suggested: "Shouldn't we move this db to user home directory for better?"
  - **Rationale**: Separate data from code, prevent accidental commits, survive reinstalls, follow best practices
  
  **5. Implementation Challenges & Solutions:**
  
  **Challenge #1: Configuration Not Updating**
  - Initial attempt: Changed `database_url` field to use f-string with `Path.home()`
  - Issue: F-strings evaluate at class definition time, not instance creation time
  - Result: Old path still being used
  
  **Challenge #2: Python Bytecode Caching**
  - Cleared `__pycache__` directories
  - Still getting old value due to import-time evaluation
  
  **Challenge #3: Environment Variable Override**
  - Root cause discovered: `.env` file had hardcoded `DATABASE_URL=sqlite+aiosqlite:///./data/autotuner.db`
  - Pydantic Settings reads `.env` file and overrides defaults
  
  **Final Solution:**
  - Updated `core/config.py` to use `Field(default_factory=get_default_database_url)`
    * `default_factory` provides lazy evaluation (called at instance creation)
    * `get_default_database_url()` function returns path at runtime
  - Updated `.env` file to comment out `DATABASE_URL` line
  - Converted from old `class Config` to Pydantic v2 `model_config = SettingsConfigDict(...)`
  - Removed old `web/backend/data/` directory
  
  **6. Database Migration Success:**
  ```python
  # New configuration in core/config.py
  def get_default_database_url() -> str:
      return f"sqlite+aiosqlite:///{Path.home()}/.local/share/inference-autotuner/autotuner.db"
  
  class Settings(BaseSettings):
      model_config = SettingsConfigDict(env_file=".env", case_sensitive=False)
      database_url: str = Field(default_factory=get_default_database_url)
  ```
  
  **7. Final Verification:**
  - ‚úÖ Database location: `~/.local/share/inference-autotuner/autotuner.db`
  - ‚úÖ Data migrated successfully (existing task preserved)
  - ‚úÖ Server connects to home directory database
  - ‚úÖ API responds correctly with historical data
  - ‚úÖ Follows XDG Base Directory specification
  
  **Benefits Achieved:**
  1. **Data Persistence**: User data independent of codebase
  2. **No Accidental Commits**: User data separated from repository
  3. **Survives Reinstallation**: Delete/reinstall code, keep data
  4. **Multi-User Support**: Each user gets own database in their home
  5. **Easy Backup**: Just backup `~/.local/share/inference-autotuner/`
  6. **Standard Practice**: Follows Linux filesystem hierarchy conventions
  
  **Files Modified:**
  1. ‚úÖ `web/backend/core/config.py` - Added `get_default_database_url()`, used `Field(default_factory=...)`, migrated to Pydantic v2 `model_config`
  2. ‚úÖ `web/backend/.env` - Commented out `DATABASE_URL` to use default
  3. ‚úÖ Removed `web/backend/data/` directory
  
  **Current Status:**
  - Database: `~/.local/share/inference-autotuner/autotuner.db` (36KB)
  - API: Running on `http://localhost:8000`
  - Health: All systems operational
  - Data: 1 task preserved from initial testing
  
  **Key Technical Lessons:**
  1. Pydantic Settings environment variable precedence: `.env` file > default values
  2. Field default values evaluate at class definition time (use `default_factory` for runtime evaluation)
  3. Pydantic v2 uses `model_config = SettingsConfigDict(...)` instead of `class Config`
  4. Python bytecode caching can hide configuration changes during development
  5. XDG Base Directory: `~/.local/share/` for user-specific data files

</details>

---

## Milestone: Code Reorganization - Consolidating Source Structure (Oct 24, 2025)

> Reorganize source code in src/, merge web/backend folder into it.

<details>
  <summary>Consolidated all source code under src/ by merging web/backend into src/web/</summary>

* *Claude*:
  **Objective:** Consolidate all source code under a single `src/` directory by merging the separate `web/backend/` structure into `src/web/`. This improves project organization, reduces directory depth, and creates a more intuitive structure for development.

  **Problem Statement:**

  The project had a confusing dual-root structure:
  - Core autotuner code: `/root/work/inference-autotuner/src/`
  - Web API code: `/root/work/inference-autotuner/web/backend/`

  This created confusion about where code should live and made imports inconsistent. User requested consolidation into a single source tree under `src/`.

  **Implementation Process:**

  **1. Created New Directory Structure:**

  ```bash
  src/
  ‚îú‚îÄ‚îÄ controllers/          # Existing: OME, Docker, Benchmark controllers
  ‚îú‚îÄ‚îÄ utils/               # Existing: Optimizer, helper functions
  ‚îú‚îÄ‚îÄ templates/           # Existing: Kubernetes YAML templates
  ‚îú‚îÄ‚îÄ orchestrator.py      # Previously separated from run_autotuner.py
  ‚îú‚îÄ‚îÄ run_autotuner.py     # CLI entry point
  ‚îî‚îÄ‚îÄ web/                 # NEW: Merged from web/backend/
      ‚îú‚îÄ‚îÄ __init__.py
      ‚îú‚îÄ‚îÄ app.py           # FastAPI app (was main.py)
      ‚îú‚îÄ‚îÄ server.py        # Dev server (was dev.py)
      ‚îú‚îÄ‚îÄ config.py        # Settings (was core/config.py)
      ‚îú‚îÄ‚îÄ .env
      ‚îú‚îÄ‚îÄ .env.example
      ‚îú‚îÄ‚îÄ routes/          # API endpoints (was api/)
      ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
      ‚îÇ   ‚îú‚îÄ‚îÄ tasks.py
      ‚îÇ   ‚îú‚îÄ‚îÄ experiments.py
      ‚îÇ   ‚îî‚îÄ‚îÄ system.py
      ‚îú‚îÄ‚îÄ db/              # Database layer
      ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
      ‚îÇ   ‚îú‚îÄ‚îÄ models.py
      ‚îÇ   ‚îî‚îÄ‚îÄ session.py
      ‚îú‚îÄ‚îÄ schemas/         # Pydantic schemas
      ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
      ‚îÇ   ‚îî‚îÄ‚îÄ (schema files)
      ‚îî‚îÄ‚îÄ workers/         # ARQ background workers
          ‚îú‚îÄ‚îÄ __init__.py
          ‚îú‚îÄ‚îÄ autotuner_worker.py
          ‚îî‚îÄ‚îÄ client.py
  ```

  **2. File Renaming Strategy:**

  - `web/backend/main.py` ‚Üí `src/web/app.py` (more descriptive name for FastAPI app)
  - `web/backend/dev.py` ‚Üí `src/web/server.py` (clearer purpose)
  - `web/backend/core/config.py` ‚Üí `src/web/config.py` (flattened hierarchy)
  - `web/backend/api/` ‚Üí `src/web/routes/` (standard REST API naming)
  - All other directories maintained their names

  **3. Import Path Updates:**

  Systematic changes across all 15 Python files:

  **Before:**
  ```python
  from core.config import get_settings
  from db.models import Task, Experiment
  from db.session import get_db, init_db
  from api import tasks, experiments, system
  from schemas import TaskCreate, TaskResponse
  ```

  **After:**
  ```python
  from web.config import get_settings
  from web.db.models import Task, Experiment
  from web.db.session import get_db, init_db
  from web.routes import tasks, experiments, system
  from web.schemas import TaskCreate, TaskResponse
  ```

  **Files Modified with Import Updates:**
  1. ‚úÖ `src/web/app.py` - Main FastAPI application
  2. ‚úÖ `src/web/server.py` - Development server runner
  3. ‚úÖ `src/web/routes/tasks.py` - Task API endpoints
  4. ‚úÖ `src/web/routes/experiments.py` - Experiment API endpoints
  5. ‚úÖ `src/web/routes/system.py` - Health and system info endpoints
  6. ‚úÖ `src/web/db/session.py` - Database session management
  7. ‚úÖ `src/web/db/models.py` - SQLAlchemy models
  8. ‚úÖ `src/web/workers/client.py` - ARQ client for job enqueueing
  9. ‚úÖ `src/web/workers/autotuner_worker.py` - Background worker tasks

  **4. Special Case: Worker File Path Resolution:**

  `src/web/workers/autotuner_worker.py` needs to import from both `src.web.*` and `src.orchestrator`, requiring special handling:

  ```python
  # Add project root to path for imports
  # workers/autotuner_worker.py -> web -> src -> project_root
  project_root = Path(__file__).parent.parent.parent.parent
  sys.path.insert(0, str(project_root))

  from src.web.config import get_settings
  from src.web.db.models import Task, Experiment, TaskStatus, ExperimentStatus
  from src.orchestrator import AutotunerOrchestrator
  from src.utils.optimizer import generate_parameter_grid, calculate_objective_score
  ```

  This worker imports use `src.` prefix because it adds the project root to sys.path, while other files under `src/web/` use relative imports from the `web.*` namespace.

  **5. Circular Import Resolution:**

  Initial import test revealed circular dependency:

  ```
  ModuleNotFoundError: No module named 'db'
  ```

  **Root Cause:** `src/web/db/__init__.py` was re-exporting all models and session functions:

  ```python
  # BEFORE (caused circular import)
  from .models import Task, Experiment, TaskStatus, ExperimentStatus, Base
  from .session import get_db, init_db
  __all__ = ["Task", "Experiment", "TaskStatus", "ExperimentStatus", "Base", "get_db", "init_db"]
  ```

  **Solution:** Simplified to just package marker:

  ```python
  # AFTER (breaks circular dependency)
  """Database package."""
  ```

  Modules now import directly from `web.db.models` and `web.db.session` instead of re-exported names from `web.db`.

  **6. Requirements.txt Consolidation:**

  Merged dependencies from both locations:

  **Before:**
  - `/root/work/inference-autotuner/requirements.txt` - Core autotuner deps
  - `/root/work/inference-autotuner/web/backend/requirements.txt` - Web API deps

  **After:**
  - Single `/root/work/inference-autotuner/requirements.txt` with deduplicated dependencies

  **7. Server Configuration Update:**

  Updated uvicorn app reference in `src/web/server.py`:

  ```python
  # BEFORE
  uvicorn.run("main:app", host="0.0.0.0", port=8000, reload=True)

  # AFTER
  uvicorn.run("web.app:app", host="0.0.0.0", port=8000, reload=True)
  ```

  **8. Issues Encountered and Fixed:**

  **Issue 1: Missed Import in system.py**
  ```
  Error: ModuleNotFoundError: No module named 'core'
  Location: src/web/routes/system.py:11
  Fix: Changed `from core.config` to `from web.config`
  ```

  **Issue 2: Worker Files Using Old Import Pattern**
  ```
  Error: Found `from src.web.config` in client.py
  Fix: Changed to `from web.config` for consistency
  Note: autotuner_worker.py correctly uses `src.` prefix due to sys.path manipulation
  ```

  **Issue 3: Circular Import in db Package**
  ```
  Error: ModuleNotFoundError when importing web.app
  Cause: db/__init__.py importing from .models which imports from .session which imports from db
  Fix: Removed re-exports from db/__init__.py, use direct imports instead
  ```

  **9. Testing and Verification:**

  **Import Test:**
  ```bash
  cd /root/work/inference-autotuner
  python -c "
  import sys
  sys.path.insert(0, 'src')
  from web.app import app
  print('‚úì Successfully imported FastAPI app')
  print(f'‚úì App title: {app.title}')
  print(f'‚úì App version: {app.version}')
  "
  ```

  **Output:**
  ```
  ‚úì Successfully imported FastAPI app
  ‚úì App title: LLM Inference Autotuner API
  ‚úì App version: 0.1.0
  ```

  **Server Start Test:**
  ```bash
  cd /root/work/inference-autotuner/src
  python -c "
  import uvicorn
  uvicorn.run('web.app:app', host='0.0.0.0', port=8000, reload=False)
  "
  ```

  **Output:**
  ```
  INFO: Started server process
  INFO: Waiting for application startup.
  üöÄ Starting LLM Inference Autotuner API...
  INFO: Application startup complete.
  INFO: Uvicorn running on http://0.0.0.0:8000
  ```

  **Database Initialization:**
  ```
  INFO sqlalchemy.engine.Engine BEGIN (implicit)
  INFO sqlalchemy.engine.Engine PRAGMA main.table_info("tasks")
  INFO sqlalchemy.engine.Engine PRAGMA main.table_info("experiments")
  INFO sqlalchemy.engine.Engine COMMIT
  ```

  All systems operational! ‚úÖ

  **10. Cleanup:**

  ```bash
  # Remove old directory structure
  rm -rf /root/work/inference-autotuner/web/backend
  rmdir /root/work/inference-autotuner/web  # Directory now empty
  ```

  **Files Removed:**
  - Entire `web/backend/` tree (15 Python files, config files, docs)
  - Empty `web/` parent directory

  **Final Project Structure:**

  ```
  /root/work/inference-autotuner/
  ‚îú‚îÄ‚îÄ src/                          # Single unified source tree
  ‚îÇ   ‚îú‚îÄ‚îÄ controllers/             # Deployment controllers
  ‚îÇ   ‚îú‚îÄ‚îÄ utils/                   # Shared utilities
  ‚îÇ   ‚îú‚îÄ‚îÄ templates/               # K8s templates
  ‚îÇ   ‚îú‚îÄ‚îÄ web/                     # Web API (formerly web/backend)
  ‚îÇ   ‚îú‚îÄ‚îÄ orchestrator.py
  ‚îÇ   ‚îî‚îÄ‚îÄ run_autotuner.py
  ‚îú‚îÄ‚îÄ examples/                     # Task JSON files
  ‚îú‚îÄ‚îÄ config/                       # K8s resource configs
  ‚îú‚îÄ‚îÄ docs/                         # Documentation
  ‚îú‚îÄ‚îÄ requirements.txt              # Consolidated dependencies
  ‚îî‚îÄ‚îÄ README.md
  ```

  **Benefits Achieved:**

  1. **Single Source Tree**: All code under `src/`, no ambiguity about where files belong
  2. **Clearer Structure**: `src/web/` clearly indicates web API components
  3. **Consistent Imports**: All web modules use `web.*` namespace
  4. **Reduced Depth**: Eliminated `web/backend/core/` nesting
  5. **Better IDE Support**: Single source root improves autocomplete and navigation
  6. **Easier Testing**: Single PYTHONPATH entry: `src/`
  7. **Standard Python Layout**: Follows conventional project structure

  **Running the Web API (Updated):**

  From project root:
  ```bash
  cd /root/work/inference-autotuner/src
  /root/work/inference-autotuner/env/bin/python web/server.py
  ```

  Or with uvicorn directly:
  ```bash
  cd /root/work/inference-autotuner/src
  uvicorn web.app:app --host 0.0.0.0 --port 8000
  ```

  Or for production:
  ```bash
  cd /root/work/inference-autotuner/src
  uvicorn web.app:app --host 0.0.0.0 --port 8000 --workers 4
  ```

  **Key Technical Lessons:**

  1. **Circular Import Prevention**: Package `__init__.py` files that re-export from submodules can create circular dependencies. Keep `__init__.py` minimal or use lazy imports.

  2. **Import Path Consistency**: Worker files that manipulate `sys.path` need different import patterns than regular modules. Document these special cases clearly.

  3. **Module Renaming**: When renaming core modules like `main.py` to `app.py`, update all string references (not just imports):
    - Uvicorn app strings: `"main:app"` ‚Üí `"web.app:app"`
    - Documentation and README files
    - Docker/K8s configurations if applicable

  4. **Batch Import Updates**: Use `sed` for systematic replacements across multiple files:
    ```bash
    sed -i 's/from db\./from web.db./g' src/web/routes/*.py
    sed -i 's/from schemas/from web.schemas/g' src/web/routes/*.py
    ```

  5. **Testing Strategy**: Test imports before starting the server. A simple import test catches 90% of path issues:
    ```python
    import sys
    sys.path.insert(0, 'src')
    from web.app import app  # Will fail fast if imports broken
    ```

  6. **Directory Structure Validation**: After major reorganizations, verify file counts match:
    ```bash
    find old_location -name "*.py" | wc -l  # Should equal
    find new_location -name "*.py" | wc -l  # this number
    ```

  7. **Incremental Testing**: Don't delete old code until new structure fully verified. Keep old directory until all tests pass.

  **Files Modified/Created (Summary):**

  **Moved & Renamed:**
  - ‚úÖ 15 Python files from `web/backend/` to `src/web/`
  - ‚úÖ Configuration files (`.env`, `.env.example`)
  - ‚úÖ `README.md` from backend to web

  **Import Updates:**
  - ‚úÖ 9 files with import path changes
  - ‚úÖ Fixed 20+ import statements total

  **Deleted:**
  - ‚úÖ `web/backend/` directory (entire tree)
  - ‚úÖ `web/` empty parent directory

  **Current Status:**
  - Source Structure: Single `src/` tree with `src/web/` subdirectory
  - Import Paths: Consistent `web.*` namespace throughout
  - Server: Starts successfully, all endpoints operational
  - Database: Connects properly to `~/.local/share/inference-autotuner/autotuner.db`
  - Tests: Import tests pass ‚úÖ, server starts ‚úÖ, API responds ‚úÖ

  **Lines Changed:**
  - Files modified: 11 files
  - Import statements updated: 22 occurrences
  - Lines of code affected: ~50 lines
  - Directory structure: Reduced from 2 source roots to 1

  This reorganization creates a cleaner, more maintainable project structure that will scale better as the codebase grows. All future development now has a clear home under `src/`, with web API components logically grouped under `src/web/`.

  ### Post-Reorganization: Server Path Fix & Documentation Updates

  **Follow-up Work (Oct 24, 2025)**

  After completing the code reorganization, three additional tasks were required to finalize the milestone:

  **1. Web Server Path Configuration Issue**

  **Problem:** The reorganized `src/web/server.py` failed to start with uvicorn reload mode:
  ```
  ModuleNotFoundError: No module named 'web'
  ```

  **Root Cause:** Uvicorn's reload mode spawns a subprocess that couldn't find the `web` module because:
  - The subprocess doesn't inherit the working directory properly
  - Python's module search path wasn't configured for the reload subprocess

  **Solution:** Updated `src/web/server.py` to configure sys.path dynamically:

  ```python
  import sys
  from pathlib import Path
  import uvicorn

  if __name__ == "__main__":
      # Ensure we're running from src/ directory
      src_dir = Path(__file__).parent.parent
      sys.path.insert(0, str(src_dir))

      uvicorn.run(
          "web.app:app",
          host="0.0.0.0",
          port=8000,
          reload=True,
          reload_dirs=[str(src_dir)],  # Watch src/ directory
          log_level="info",
      )
  ```

  **Key Changes:**
  - Dynamically calculates `src/` directory: `Path(__file__).parent.parent`
  - Adds src/ to sys.path before uvicorn.run()
  - Explicitly sets `reload_dirs=[str(src_dir)]` for hot-reload

  **Testing Results:**
  ```bash
  ‚úì Server starts successfully from any directory
  ‚úì Hot reload works correctly
  ‚úì All API endpoints operational
  ‚úì Database connects properly
  ```

  **API Endpoints Verified:**
  - `GET /health` ‚Üí 200 OK
  - `GET /api/system/info` ‚Üí 200 OK (returns app name, version, mode)
  - `GET /api/tasks/` ‚Üí 200 OK (returns task list)
  - `GET /api/tasks/1` ‚Üí 200 OK (returns task details)
  - `GET /api/experiments/task/1` ‚Üí 200 OK (returns experiments)
  - `GET /docs` ‚Üí 200 OK (Swagger UI)

  **2. README.md Updates**

  Updated README to reflect all changes from milestone:

  **Added Sections:**
  - **Features** (lines 5-9): Web API, background processing, database
  - **Web API** (lines 56-94): Complete API documentation
    - Starting the server
    - Key endpoints list
    - Database storage location
  - **Project Structure** (lines 96-133): Visual directory tree
    - Shows unified `src/` structure
    - Documents `src/web/` integration
    - Explains key components
  - **Current Implementation Status** (lines 481-497): Progress tracking
    - Marked completed items: ‚úÖ Database, ‚úÖ REST API
    - Listed TODO items with priorities

  **Updated Sections:**
  - **Prerequisites**: Added Redis, consolidated requirements
  - **Limitations**: Strikethrough completed items
  - **Next Steps**: Updated with completed/pending items
  - **Documentation**: Added links section

  **Statistics:**
  - Previous: 417 lines
  - Updated: 534 lines
  - Added: 117 lines (28% increase)

  **3. install.sh Updates**

  Updated installation script to support new structure:

  **New Section 8: Web API Dependencies Check (lines 252-292)**
  ```bash
  # Check Redis availability
  if command -v redis-cli &> /dev/null; then
      if redis-cli ping &> /dev/null; then
          log_success "Redis is running and accessible"
      else
          log_warning "Redis is installed but not running"
      fi
  fi

  # Verify Web API packages
  WEB_PACKAGES=("fastapi" "uvicorn" "sqlalchemy" "aiosqlite" "arq")
  for package in "${WEB_PACKAGES[@]}"; do
      if python3 -c "import $package" 2>/dev/null; then
          log_success "Web API package '$package' is available"
      fi
  done
  ```

  **Updated Section 7: Database Directory Creation (lines 245-248)**
  ```bash
  DB_DIR="$HOME/.local/share/inference-autotuner"
  mkdir -p "$DB_DIR"
  log_success "Database directory created at: $DB_DIR"
  ```

  **Updated Section 10: Enhanced Summary (lines 470-521)**
  - Added Web API startup instructions
  - Added Redis setup instructions
  - Updated CLI examples with `--mode` flags
  - Added API endpoint examples
  - Displays database location

  **Statistics:**
  - Previous: 460 lines
  - Updated: 526 lines
  - Added: 66 lines (14% increase)

  **Complete Milestone Summary:**

  **Code Changes:**
  - ‚úÖ 15 files moved/renamed
  - ‚úÖ 22 import statements updated
  - ‚úÖ Server path configuration fixed
  - ‚úÖ All tests passing

  **Documentation Changes:**
  - ‚úÖ README.md: +117 lines
  - ‚úÖ install.sh: +66 lines
  - ‚úÖ prompts.md: +358 lines (initial) + this follow-up

  **Verification:**
  - ‚úÖ Web server starts from any directory
  - ‚úÖ All API endpoints respond correctly
  - ‚úÖ Database operations work
  - ‚úÖ Installation script syntax validated
  - ‚úÖ Documentation is comprehensive and accurate

  **Final Project State:**
  ```
  src/
  ‚îú‚îÄ‚îÄ controllers/       # Deployment controllers
  ‚îú‚îÄ‚îÄ utils/            # Utilities
  ‚îú‚îÄ‚îÄ templates/        # K8s templates
  ‚îú‚îÄ‚îÄ web/              # Web API (NEW)
  ‚îÇ   ‚îú‚îÄ‚îÄ app.py       # FastAPI application
  ‚îÇ   ‚îú‚îÄ‚îÄ server.py    # Development server (FIXED)
  ‚îÇ   ‚îú‚îÄ‚îÄ routes/      # API endpoints
  ‚îÇ   ‚îú‚îÄ‚îÄ db/          # Database layer
  ‚îÇ   ‚îú‚îÄ‚îÄ schemas/     # Pydantic schemas
  ‚îÇ   ‚îî‚îÄ‚îÄ workers/     # Background workers
  ‚îú‚îÄ‚îÄ orchestrator.py  # Main orchestration
  ‚îî‚îÄ‚îÄ run_autotuner.py # CLI entry point
  ```

  **Database:** `~/.local/share/inference-autotuner/autotuner.db`
  **Web Server:** `http://0.0.0.0:8000` with hot reload
  **API Docs:** `http://0.0.0.0:8000/docs` (Swagger UI)

  The milestone is now complete with all code reorganized, server working correctly, and documentation fully updated to reflect the new structure.

</details>

---
